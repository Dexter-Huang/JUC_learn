## 前言

功能中为了学习更核心的知识，功能只涉及到前后端分离开发中的功能，因此和SpringMvc的功能有些出处，但是不影响整体流程->少了视图解析器

## 准备工作

环境搭建：

tomcat安装

<https://tomcat.apache.org/download-90.cgi>

![img](https://cdn.nlark.com/yuque/0/2023/png/29091062/1697197352189-7dd2793b-f4b1-4f0f-81db-9d3b3028bdda.png)

依赖准备

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.apache.tomcat</groupId>
  <artifactId>tomcat9</artifactId>
  <name>tomcat-9.0.44</name>
  <version>9.0.44</version>
  <build>
    <finalName>tomcat-9.0.44</finalName>
    <sourceDirectory>java</sourceDirectory>
    <resources>
      <resource>
        <directory>java</directory>
      </resource>
    </resources>
    <testResources>
      <testResource>
        <directory>test</directory>
      </testResource>
    </testResources>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.6.0</version>
        <configuration>
          <encoding>UTF-8</encoding>
          <source>1.8</source>
          <target>1.8</target>
          <compilerArgs>
            <arg>-parameters</arg>
          </compilerArgs>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <version>3.0.2</version>

      </plugin>
    </plugins>
  </build>
  <dependencies>

    <dependency>
      <groupId>org.apache.ant</groupId>
      <artifactId>ant</artifactId>
      <version>1.9.5</version>
    </dependency>
    <dependency>
      <groupId>biz.aQute.bnd</groupId>
      <artifactId>biz.aQute.bndlib</artifactId>
      <version>5.2.0</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.apache.tomcat</groupId>
      <artifactId>tomcat-jasper</artifactId>
      <version>9.0.41</version>
    </dependency>
    <dependency>
      <groupId>org.apache.ant</groupId>
      <artifactId>ant-apache-log4j</artifactId>
      <version>1.9.5</version>
    </dependency>
    <dependency>
      <groupId>org.apache.ant</groupId>
      <artifactId>ant-commons-logging</artifactId>
      <version>1.9.5</version>
    </dependency>
    <dependency>
      <groupId>javax.xml.rpc</groupId>
      <artifactId>javax.xml.rpc-api</artifactId>
      <version>1.1</version>
    </dependency>
    <dependency>
      <groupId>wsdl4j</groupId>
      <artifactId>wsdl4j</artifactId>
      <version>1.6.2</version>
    </dependency>
    <dependency>
      <groupId>org.eclipse.jdt.core.compiler</groupId>
      <artifactId>ecj</artifactId>
        <version>4.6.1</version>
        </dependency>
        </dependencies>
        </project>
```

删除不必要文件

测试tomcat

`public class demo extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        super.doGet(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        super.doPost(req, resp);    }}`

`<servlet>    <servlet-name>HelloServlet</servlet-name>    <servlet-class>org.xhy.WebServlet</servlet-class>  </servlet>  <servlet-mapping>    <servlet-name>HelloServlet</servlet-name>    <url-pattern>/hello</url-pattern>  </servlet-mapping>`

## 整体设计架构

1.架构图/流程图

![img](https://cdn.nlark.com/yuque/0/2023/png/29091062/1697215189162-e6f058b1-32e6-460f-af6d-61595244a2d9.png)

### 环境搭建

依赖

```
<dependencies>

  <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.11.0</version>
    <scope>compile</scope>
  </dependency>

  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
    <version>5.3.23</version>
    <scope>compile</scope>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.23</version>
    <scope>compile</scope>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>5.3.23</version>
    <scope>compile</scope>
  </dependency>
</dependencies>
```

build

```
<build>
        <finalName>xhy-web</finalName>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                </includes>
                <filtering>false</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
                <includes>
                    <include>**/**</include>
                </includes>
            </resource>
        </resources>
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
                <includes>
                    <include>**/**</include>
                </includes>
            </testResource>
        </testResources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.12.4</version>
                <configuration>
                    <skipTests>true</skipTests>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>2.5</version>
                <configuration>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.6.0</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>2.1.2</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

## 容器

需要容器管理所有bean，这和spring没关系，可以想像一下，如果没有引入spring的话，依然需要一个容器(map)管理维护所有的bean

以spring基础开发后，可以利用spring ioc的原则进行开发web ioc容器。 -> 父子容器概念

**目标：**

设计并实现web ioc 

**设计：**

**1.web ioc设计**

因为需要自己设计一个web容器，因此要遵循spring ioc原则，将职责划分几个部分：

1.WebApplicationContext：web ioc顶级接口

2.ConfigurableWebApplicationContext: 存放servlet context 定义规范

3.AbstractRefreshableWebApplicationContext：容器刷新接入点，接入行为

4.AnnotationConfigWebApplicationContext web ioc实现：注解版

![img](https://cdn.nlark.com/yuque/0/2023/png/29091062/1697166668526-4a38ae28-9a80-45a9-80ea-94db8f802645.png)

**2.初始化ioc**

tomcat留有一个拓展点 -> ServletContainerInitializer。在SCI中有@HandlesTypes注解可以获取感兴趣的类，因此我们在此进行ioc初始化以及后续的 DispatcherServlet 初始化

**实现：**

### ioc设计与实现

创建context包，存放web ioc相关类

1.创建web ioc根接口

```
public interface WebApplicationContext extends  ApplicationContext {

    String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + ".ROOT";

    String CHILD_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + ".CHILD";

}
```

2.创建ConfigurableWebApplicationContext，用于制定存放ServletContext和ServletConfig规范

ServletContext和ServletConfig是Servlet中的上下文以及配置类，因此我们需要将其保存下来

```
public interface ConfigurableWebApplicationContext extends WebApplicationContext, ConfigurableApplicationContext {

    void setServletContext(@Nullable ServletContext servletContext);


    void setServletConfig(@Nullable ServletConfig servletConfig);


    ServletConfig getServletConfig();


    ServletContext getServletContext();
}
```

3.创建AbstractRefreshableWebApplicationContext继承AbstractRefreshableConfigApplicationContext，用于容器刷新接入点，插入行为

```
public abstract class AbstractRefreshableWebApplicationContext extends AbstractRefreshableConfigApplicationContext
        implements ConfigurableWebApplicationContext {


    private ServletContext servletContext;

    private ServletConfig servletConfig;


    @Override
    public void setServletContext(ServletContext servletContext) {
        this.servletContext = servletContext;
    }

    @Override
    public void setServletConfig(ServletConfig servletConfig) {
        this.servletConfig = servletConfig;
    }

    @Override
    public ServletConfig getServletConfig() {
        return this.servletConfig;
    }

    @Override
    public ServletContext getServletContext(){
        return this.servletContext;
    }


    @Override
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 注册ServletContext后置处理器
        beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext,this.servletConfig));

        /**
         * A类中有test方法，B类实现A类，且有一个test属性。也就是说当前会有一个set方法和一个set注入。
         * 在特定场景下会干扰。因此忽略set注入
         */
        beanFactory.ignoreDependencyInterface(ServletContextAware.class);
        beanFactory.ignoreDependencyInterface(ServletConfig.class);
    }
}
```

4.创建Servlet上下文后置处理器 ServletContextAwareProcessor

```
public class ServletContextAwareProcessor implements BeanPostProcessor {

    private ServletContext servletContext;

    private ServletConfig servletConfig;


    public ServletContextAwareProcessor(ServletContext servletContext,ServletConfig servletConfig){
        this.servletConfig = servletConfig;
        this.servletContext = servletContext;
    }
    public ServletContextAwareProcessor(ServletContext servletContext){
        this(servletContext,null);
    }
    public ServletContextAwareProcessor(ServletConfig servletConfig){
        this(null,servletConfig);
    }

    public ServletConfig getServletConfig() {
        return servletConfig;
    }

    public ServletContext getServletContext() {
        return servletContext;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (getServletContext() != null && bean instanceof ServletContextAware) {
            ((ServletContextAware) bean).setServletContext(getServletContext());
        }
        if (getServletConfig() != null && bean instanceof ServletConfigAware) {
            ((ServletConfigAware) bean).setServletConfig(getServletConfig());
        }
        return bean;
    }
}
```

XXXAware

```
public interface ServletContextAware extends Aware {

    void setServletContext(ServletContext servletContext);
}
```

```
public interface ServletConfigAware extends Aware {

    void setServletConfig(ServletConfig servletConfig);
}
```

5.创建容器具体实现类 AnnotationConfigWebApplicationContext 

```
public class AnnotationConfigWebApplicationContext extends AbstractRefreshableWebApplicationContext implements AnnotationConfigRegistry {

    @Nullable
    private BeanNameGenerator beanNameGenerator;

    @Nullable
    private ScopeMetadataResolver scopeMetadataResolver;

    private final Set<Class<?>> componentClasses = new LinkedHashSet<>();

    private final Set<String> basePackages = new LinkedHashSet<>();


    // 复制粘贴即可
    @Override
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);
        ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);

        BeanNameGenerator beanNameGenerator = getBeanNameGenerator();
        if (beanNameGenerator != null) {
            reader.setBeanNameGenerator(beanNameGenerator);
            scanner.setBeanNameGenerator(beanNameGenerator);
            beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
        }

        ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();
        if (scopeMetadataResolver != null) {
            reader.setScopeMetadataResolver(scopeMetadataResolver);
            scanner.setScopeMetadataResolver(scopeMetadataResolver);
        }

        if (!this.componentClasses.isEmpty()) {
            if (logger.isDebugEnabled()) {
                logger.debug("Registering component classes: [" +
                        StringUtils.collectionToCommaDelimitedString(this.componentClasses) + "]");
            }
            reader.register(ClassUtils.toClassArray(this.componentClasses));
        }

        if (!this.basePackages.isEmpty()) {
            if (logger.isDebugEnabled()) {
                logger.debug("Scanning base packages: [" +
                        StringUtils.collectionToCommaDelimitedString(this.basePackages) + "]");
            }
            scanner.scan(StringUtils.toStringArray(this.basePackages));
        }

        String[] configLocations = getConfigLocations();
        if (configLocations != null) {
            for (String configLocation : configLocations) {
                try {
                    Class<?> clazz = ClassUtils.forName(configLocation, getClassLoader());
                    if (logger.isTraceEnabled()) {
                        logger.trace("Registering [" + configLocation + "]");
                    }
                    reader.register(clazz);
                } catch (ClassNotFoundException ex) {
                    if (logger.isTraceEnabled()) {
                        logger.trace("Could not load class for config location [" + configLocation +
                                "] - trying package scan. " + ex);
                    }
                    int count = scanner.scan(configLocation);
                    if (count == 0 && logger.isDebugEnabled()) {
                        logger.debug("No component classes found for specified class/package [" + configLocation + "]");
                    }
                }
            }
        }
    }

    protected AnnotatedBeanDefinitionReader getAnnotatedBeanDefinitionReader(DefaultListableBeanFactory beanFactory) {
        return new AnnotatedBeanDefinitionReader(beanFactory, getEnvironment());
    }


    protected ClassPathBeanDefinitionScanner getClassPathBeanDefinitionScanner(DefaultListableBeanFactory beanFactory) {
        return new ClassPathBeanDefinitionScanner(beanFactory, true, getEnvironment());
    }

    protected BeanNameGenerator getBeanNameGenerator() {
        return this.beanNameGenerator;
    }

    protected ScopeMetadataResolver getScopeMetadataResolver() {
        return this.scopeMetadataResolver;
    }

    @Override
    public void register(Class<?>... componentClasses) {
        Assert.notEmpty(componentClasses, "At least one component class must be specified");
        Collections.addAll(this.componentClasses, componentClasses);
    }

    @Override
    public void scan(String... basePackages) {
        Assert.notEmpty(basePackages, "At least one base package must be specified");
        Collections.addAll(this.basePackages, basePackages);
    }
}
```

### ioc初始化

**这一块需要学了DispatcherServlet再回来看拓展点**

在tomcat中留有拓展点ServletContainerInitializer。

ServletContainerInitializer的子类由SPI进行加载

@HandlesTypes(WebApplicationInitializer.class) 会将WebApplicationInitializer子类传入onStartup方法中

因此可以由用户继承ioc相关类，配置相关包扫描类，初始化ioc容器

```
@HandlesTypes(WebApplicationInitializer.class)
public class XhyServletContainerInitializer implements ServletContainerInitializer {


    @Override
    public void onStartup(Set<Class<?>> webAppInitializerClasses, ServletContext servletContext) throws ServletException {
        if(webAppInitializerClasses.size()!=0){
            final List<WebApplicationInitializer> initializers = new ArrayList<>(webAppInitializerClasses.size());
            // 排除接口和抽象类
            for (Class<?> webAppInitializerClass : webAppInitializerClasses) {
                if (!webAppInitializerClass.isInterface() && !Modifier.isAbstract(webAppInitializerClass.getModifiers()) &&
                        WebApplicationInitializer.class.isAssignableFrom(webAppInitializerClass)){
                    try {
                        initializers.add((WebApplicationInitializer)
                                ReflectionUtils.accessibleConstructor(webAppInitializerClass).newInstance());
                    } catch (Throwable e) {
                       e.printStackTrace();
                    }
                }
            }
            for (WebApplicationInitializer initializer : initializers) {
                initializer.onStartUp(servletContext);
            }
        }
    }
}
```

## 对接Servlet SCI

**目标：**

1.创建DispatcherServlet

2.设计实现对接SCI

3.测试功能

**设计：**

DispatcherServlet的作用是分发请求已经管理组件，因此需要使用到ioc。

1.AbstractDispatcherServletInitializer 创建DispatcherServlet以及配置信息，路径映射，过滤器等

2.AbstractAnnotationConfigDispatcherServletInitializer 提供ioc容器配置接口

实现WebApplicationInitializer是为了利用SCI的拓展点调用onStatUp()创建DispatcherServlet

**BaseHttpServlet **

初始化ioc容器以及配置信息

```java
public abstract class BaseHttpServlet extends HttpServlet {

    // 子容器
    private ApplicationContext webApplicationContext;

    public BaseHttpServlet(ApplicationContext webApplicationContext) {
        this.webApplicationContext = webApplicationContext;
    }

    @Override
    public void init(){
        initServletContext();
    }

    private void initServletContext() {
        ApplicationContext rootContext = (ApplicationContext) getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
        AbstractRefreshableWebApplicationContext cwc = null;
        // 在springboot场景下会根据当前存在类创建不同ioc,在boot下直接不管
        if (this.webApplicationContext != null) {

            if (!(this.webApplicationContext instanceof AnnotationConfigApplicationContext)){
                cwc = (AbstractRefreshableWebApplicationContext) this.webApplicationContext;
                if (cwc.getParent() == null) {
                    cwc.setParent(rootContext);
                }
                if (!cwc.isActive()) {
                    cwc.refresh();
                }
                cwc.setServletConfig(getServletConfig());
                cwc.setServletContext(getServletContext());
            }

            onRefresh(webApplicationContext);
        }
    }

    protected abstract void onRefresh(ApplicationContext applicationContext);
}

```

**DispatcherServlet **用于请求派发，组件初始化

DispatcherServlet作用是接受所有请求，对其进行请求分发，因此需要是一个Servlet



对接SCI拓展点类图

![img](https://cdn.nlark.com/yuque/0/2023/png/29091062/1697193439465-c7e5f8dc-5dc3-47ba-b696-b58ad7f5e31c.png)

**AbstractDispatcherServletInitializer** 

主要核心是onStartUp()中创建ioc和创建DispatcherServlet

```java
public abstract class AbstractDispatcherServletInitializer implements WebApplicationInitializer {


    protected static final String DEFAULT_SERVLET_NAME = "dispatcher";

    protected static final String DEFAULT_FILTERS_NAME = "filter";

    @Override
    public void onStartUp(ServletContext servletContext) {

        final String servletName = getServletName();
        final AnnotationConfigApplicationContext rootContext = createRootApplicationContext();

        if (!rootContext.isActive()) {
            rootContext.refresh();
        }

        // 放入servletContext上下文后续 DispatcherServlet 需要获取设置父容器
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, rootContext);
        // 创建web ioc放入DispatcherServlet
        final WebApplicationContext servletApplicationContext = createServletApplicationContext();
        final DispatcherServlet dispatcherServlet = new DispatcherServlet(servletApplicationContext);

        final ServletRegistration.Dynamic dynamic = servletContext.addServlet(servletName, dispatcherServlet);

        dynamic.setLoadOnStartup(1);
        dynamic.addMapping(getServletMappings());
        final MultipartConfigElement multipartConfigElement = new MultipartConfigElement(null, 500000, 500000, 5);
        dynamic.setMultipartConfig(multipartConfigElement);
        // 添加过滤器
        final Filter[] filters = getServletFilters();
        if (!ObjectUtils.isEmpty(filters)) {
            for (Filter filter : filters) {
                servletContext.addFilter(getFilterName(), filter);
            }
        }

    }


    protected abstract WebApplicationContext createServletApplicationContext();

    protected abstract AnnotationConfigApplicationContext createRootApplicationContext();


    private String getServletName() {
        return DEFAULT_SERVLET_NAME;
    }

    private String getFilterName() {
        return DEFAULT_FILTERS_NAME;
    }

    protected abstract Class<?>[] getRootConfigClasses();

    protected abstract Class<?>[] getServletConfigClasses();

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }


    protected Filter[] getServletFilters() {
        return null;
    }


}

```

**AbstractAnnotationConfigDispatcherServletInitializer** 

作用是根据留给子类的配置类创建spring ioc以及web ioc

```java
public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer {

    protected abstract Class<?>[] getRootConfigClasses();

    protected abstract Class<?>[] getServletConfigClasses();


    public WebApplicationContext createServletApplicationContext() {
        Class<?>[] configClasses = getServletConfigClasses();
        if (!ObjectUtils.isEmpty(configClasses)) {
            final AnnotationConfigWebApplicationContext serverContext = new AnnotationConfigWebApplicationContext();
            serverContext.register(configClasses);
            return serverContext;
        } else {
            return null;
        }
    }

    public AnnotationConfigApplicationContext createRootApplicationContext() {
        Class<?>[] configClasses = getRootConfigClasses();
        if (!ObjectUtils.isEmpty(configClasses)) {
            AnnotationConfigApplicationContext rootContext = new AnnotationConfigApplicationContext();
            rootContext.register(configClasses);
            return rootContext;
        } else {
            return null;
        }
    }
}

```

**对接SCI**

```java
@HandlesTypes(WebApplicationInitializer.class)
public class WebServletContainerInitializer implements ServletContainerInitializer {


    @Override
    public void onStartup(Set<Class<?>> webAppInitializerClasses, ServletContext servletContext) throws ServletException {
        if(webAppInitializerClasses.size()!=0){
            final List<WebApplicationInitializer> initializers = new ArrayList<>(webAppInitializerClasses.size());
            // 排除接口和抽象类
            for (Class<?> webAppInitializerClass : webAppInitializerClasses) {
                if (!webAppInitializerClass.isInterface() && !Modifier.isAbstract(webAppInitializerClass.getModifiers()) &&
                        WebApplicationInitializer.class.isAssignableFrom(webAppInitializerClass)){
                    try {
                        initializers.add((WebApplicationInitializer)
                                ReflectionUtils.accessibleConstructor(webAppInitializerClass).newInstance());
                    } catch (Throwable e) {
                       e.printStackTrace();
                    }
                }
            }
            for (WebApplicationInitializer initializer : initializers) {
                initializer.onStartUp(servletContext);
            }
        }
    }
}

```





## 映射器

映射器是用于根据请求路径找到对应的类/方法进行返回

**目标**

1.映射器类设计与实现

2.映射器组件初始化



**设计:**

HandlerMethod 包装对应的路径映射方法

HandlerExecutionChain 包装HandlerMethod ，用于添加拦截器功能

HandlerMapping 获取映射器(接口)

AbstractHandlerMapping 抽取共性，模板模式

**1.映射器**

映射器在初始化时需要找到路径映射的方法，因此需要拿到ioc。

映射器的作用是根据路径映射场景的不同后续处理的也不同

路径映射方式有多种:

​	1.RequestMapping

​	2.Controller 以bean名称为路径匹配

​	3.Web Flux

**2.初始化映射器**

1.BaseHttpServlet中预留的拓展点进行初始化

先从容器中拿，如果容器中没有，则使用自定义的。这样做是为了后续适配





映射器里面保存HandlerMethod

```java
@RequestMapping 带有该注解的方法
```





### 映射器实现

HandlerMapping 

映射器接口，根据请求路径获取对应的HandlerExecutionChain

HandlerExecutionChain中包含拦截器链

```
public interface HandlerMapping extends Ordered {

    HandlerExecutionChain getHandler(HttpServletRequest request) throws HttpRequestMethodNotSupportedException, Exception;
}
```

**AbstractHandlerMapping**

定义获取HandlerMethod共同功能，以及初始化映射器组件

```
public abstract class AbstractHandlerMapping extends ApplicationObjectSupport implements HandlerMapping, InitializingBean {
	 @Override
    public void afterPropertiesSet() throws Exception {
        initHandleMethods();
    }
    
    @Override
    public HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        HandlerMethod handlerInternal = getHandlerInternal(request);

        if (handlerInternal == null )return null;
        final HandlerExecutionChain executionChain = new HandlerExecutionChain();
        executionChain.setHandlerMethod(handlerInternal);
        return executionChain;
    }
}
```



**获取默认组件代码**

```java
protected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {
        if (defaultStrategies == null) {
            try {
                ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);
                defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);
            } catch (IOException ex) {
                throw new IllegalStateException("Could not load '" + DEFAULT_STRATEGIES_PATH + "': " + ex.getMessage());
            }
        }

        String key = strategyInterface.getName();
        String value = defaultStrategies.getProperty(key);
        if (value != null) {
            String[] classNames = StringUtils.commaDelimitedListToStringArray(value);
            List<T> strategies = new ArrayList<>(classNames.length);
            for (String className : classNames) {
                try {
                    Class<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());
                    Object strategy = createDefaultStrategy(context, clazz);
                    strategies.add((T) strategy);
                } catch (ClassNotFoundException ex) {
                    throw new BeanInitializationException(
                            "Could not find DispatcherServlet's default strategy class [" + className +
                                    "] for interface [" + key + "]", ex);
                } catch (LinkageError err) {
                    throw new BeanInitializationException(
                            "Unresolvable class definition for DispatcherServlet's default strategy class [" +
                                    className + "] for interface [" + key + "]", err);
                }
            }
            return strategies;
        } else {
            return Collections.emptyList();
        }
    }

    protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {
        return context.getAutowireCapableBeanFactory().createBean(clazz);
    }
```

### 注册HandlerMethod

**目标：**

1.找到所有的HandlerMethod



让AbstractHandlerMapping继承ApplicationObjectSupport以及实现InitializingBean可用于获取ioc以及初始化行为

在afterPropertiesSet中注册HandlerMethod







**实现:**

1.拿到ioc中的Object类型bean

2.遍历，是否为Handler

3.遍历所有方法，如果标有@RequestMapping则收集

4.注册handlerMethod

5.分为精确路径/模糊路径进行收集

模糊路径

```java
path = path.replaceAll("\\{\\w+\\}", "(\\\\w+)");
```



### 获取HandlerMethod



**设计:**

1.获取HandlerMethod

2.测试功能



路径匹配

```java
 final Matcher matcher = Pattern.compile(requestPath).matcher(path);
```



### 完善代码

1.对RequestMapping的派生注解补充完成

@GetMapping

@PostMapping

@PutMapping

@DeleteMapping

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@RequestMapping(requestMethod = RequestMethod.DELETE)
public @interface DeleteMapping {

    @AliasFor(annotation = RequestMapping.class)
    String value() default "";
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@RequestMapping(requestMethod = RequestMethod.GET)
public @interface GetMapping {

    @AliasFor(annotation = RequestMapping.class)
    String value() default "";
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@RequestMapping(requestMethod = RequestMethod.POST)
public @interface PostMapping {

    @AliasFor(annotation = RequestMapping.class)
    String value() default "";
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@RequestMapping(requestMethod = RequestMethod.PUT)
public @interface PutMapping {

    @AliasFor(annotation = RequestMapping.class)
    String value() default "";

}
```





2.解决bug

问题：在找HandlerMethod中

/order/get/{id}/name  PostMapping

/order/get/{id}/{name} RequestMapping

requestPath:   /order/get/1/name   DeleteMapping





因现有代码的原因，会先匹配Post，如果匹配不上则直接抛出类型不匹配，其实应该还要往下匹配





解决：

类型不匹配：路径能匹配上，但是找不到

404：路径匹配不上

>   getHandlerMethod()中返回值改为null，如果返回的不为null，说明找到了并直接return
>
>   lockUpPath() 末尾返回null，如果能找到则前面代码都treturn了
>
>   注明标注位，用于标注匹配成功了，但是没有return，说明找到路径了，但是类型没匹配上





## 适配器

根据映射器获取适配器进行执行后续逻辑(不是一对一)

**实现:**

### 适配器实现

**HandlerMethodAdapter**

```
public interface HandlerMethodAdapter {

    boolean support(Object o);
	
    void handler(HttpServletRequest req, HttpServletResponse res, Object handler) throws Exception;
}
```

不同的适配器中执行的目标方法也不同，可能A适配器需要用到参数解析器，返回值处理器等，B适配器不需要。因此我们需要在各个适配器中定制化逻辑

**RequestMappingAdapter**

处理@RequestMapping 方法的适配器

因此需要有参数解析器、类型转换器、返回值处理器、异常解析器



## 参数解析器

请求会携带各式各样的数据，因此需要将其枚举出来后定义各个参数解析器应对不同场景

**目标:**

1.枚举请求携带数据的场景 -> 类

2.参数解析器初始化

**实现:**

### 参数解析器实现

```
public interface HandlerMethodArgumentResolver {
	// 当前请求携带数据格式是否支持当前参数
    boolean supportsParameter(MethodParameter parameter);
	// 解析参数
    Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) throws Exception;
}
```

参数解析器：

1.PathVariableMapMethodArgumentResolver

解析路径参数转为map

2.PathVariableMethodArgumentResolver

解析路径参数

3.RequestCookieMethodArgumentResolver

解析cookie中的参数

4.RequestHeaderMapMethodArgumentResolver

解析请求头中参数转为map

5.RequestHeaderMethodArgumentResolver

解析请求头中的参数

6.RequestParamMapMethodArgumentResolver

解析表单参数转为map

7.RequestParamMethodArgumentResolver

解析表单参数

8.RequestPartMethodArgumentResolver

解析文件

9.RequestRequestBodyMethodArgumentResolver

解析json

10.ServletRequestMethodArgumentResolver

解析HttpServletRequest

11.ServletResponseMethodArgumentResolver

解析HttpServletResponse



在适配器中存放参数解析器，List ? 类?   创建类存放参数解析器，这样有更多功能

```java
public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver {
   private List<HandlerMethodArgumentResolver> handlerMethodArgumentResolvers = new ArrayList<>();

    private Map<MethodParameter,HandlerMethodArgumentResolver> argumentResolverCache = new ConcurrentHashMap<>();


    public List<HandlerMethodArgumentResolver> getArgumentResolvers() {
        return handlerMethodArgumentResolvers;
    }



    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers){
        this.handlerMethodArgumentResolvers.addAll(resolvers);
    }



    private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
        HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
        if (result == null) {
            for (HandlerMethodArgumentResolver resolver : this.handlerMethodArgumentResolvers) {
                if (resolver.supportsParameter(parameter)) {
                    result = resolver;
                    this.argumentResolverCache.put(parameter, result);
                    break;
                }
            }
        }
        return result;
    }


    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        final HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
        if (ObjectUtils.isEmpty(resolver)) return  false;
        return true;
    }

    @Override
    public Object resolveArgument(@PathVariable MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) throws Exception {
        final HandlerMethodArgumentResolver argumentResolver = getArgumentResolver(parameter);
        final Object value = argumentResolver.resolveArgument(parameter, handlerMethod, webServletRequest,convertComposite);
        return value;
    }

  
}
```

### 参数解析器解析参数

**RequestPartMethodArgumentResolver**

解析文件

**MultipartFile**

定义文件相关信息

```java
public interface MultipartFile extends InputStreamSource {
	
	String getName();
	
	String getOriginalFilename();
	
	String getContentType();
	
	boolean isEmpty();
	
	long getSize();

	byte[] getBytes() throws IOException;
	
	@Override
	InputStream getInputStream() throws IOException;
	
	void transferTo(File dest) throws IOException, IllegalStateException;
	
	default void transferTo(Path dest) throws IOException, IllegalStateException {
		FileCopyUtils.copy(getInputStream(), Files.newOutputStream(dest));
	}

}
```

**StandardMultipartFile**

文件上传实现类

```java
public class StandardMultipartFile  implements MultipartFile, Serializable {

    private final Part part;

    private final String filename;

    public StandardMultipartFile(Part part, String filename) {
        this.part = part;
        this.filename = filename;
    }

    @Override
    public String getName() {
        return this.part.getName();
    }

    @Override
    public String getOriginalFilename() {
        return this.filename;
    }

    @Override
    public String getContentType() {
        return this.part.getContentType();
    }

    @Override
    public boolean isEmpty() {
        return (this.part.getSize() == 0);
    }

    @Override
    public long getSize() {
        return this.part.getSize();
    }

    @Override
    public byte[] getBytes() throws IOException {
        return FileCopyUtils.copyToByteArray(this.part.getInputStream());
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return this.part.getInputStream();
    }

    @Override
    public void transferTo(File dest) throws IOException, IllegalStateException {
        this.part.write(dest.getPath());
        if (dest.isAbsolute() && !dest.exists()) {
            FileCopyUtils.copy(this.part.getInputStream(), Files.newOutputStream(dest.toPath()));
        }
    }

    @Override
    public void transferTo(Path dest) throws IOException, IllegalStateException {
        FileCopyUtils.copy(this.part.getInputStream(), Files.newOutputStream(dest));
    }
}
```





```java
public class RequestPartMethodArgumentResolver implements HandlerMethodArgumentResolver{

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return isMultipartFile(parameter);
    }


    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) {

        final HttpServletRequest request = webServletRequest.getRequest();
        final Class<?> parameterType = parameter.getParameterType();
        try {
            final Collection<Part> parts = request.getParts();
            if (parts.size() == 0) return null;
            List<MultipartFile> files = new ArrayList<>();
            for (Part part : parts) {
                StandardMultipartFile standardMultipartFile = null;
                if (part.getName().equals(parameter.getParameterName())) {
                        standardMultipartFile = new StandardMultipartFile(part,part.getSubmittedFileName());
                    files.add(standardMultipartFile);
                }
            }

            if (parameterType.isArray()){
                return files.toArray(new MultipartFile[files.size()]);
            }else if (parameterType == List.class || parameterType == Collection.class){
                return files;
            }
            return files.get(0);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ServletException e) {
            e.printStackTrace();
        }
        return null;
    }

    private boolean isMultipartFile(MethodParameter parameter){
        final Class<?> type = parameter.getParameterType();
        if (MultipartFile.class == type || type.getComponentType() == MultipartFile.class) {
            return true;
        }else if (Collection.class == type || List.class == type){
            final Type parameterGenericParameterType = parameter.getGenericParameterType();
            ParameterizedType pt = (ParameterizedType) parameterGenericParameterType;
            return pt.getActualTypeArguments()[0] == MultipartFile.class;
        }
        return false;
    }
}

```





**PathVariableMapMethodArgumentResolver**

获取路径上的参数转为map

思路：

1.获取源path，以/分割，找到带有{ }的下标以及对应的变量

2.获取请求path,以/分割，遍历map的key，找到对应下标的值，key：变量 value：对应值

```java
public class PathVariableMapMethodArgumentResolver implements HandlerMethodArgumentResolver{

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        final Annotation parameterAnnotation = parameter.getParameterAnnotation(PathVariable.class);
        if (ObjectUtils.isEmpty(parameterAnnotation)){
            return false;
        }
        return parameter.hasParameterAnnotation(PathVariable.class) && parameter.getParameterType() == Map.class;
    }

  
    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest) {
        final HttpServletRequest request = webServletRequest.getRequest();
		
        final String path = handlerMethod.getPath();
        final String requestPath = request.getRequestURI();
        String[] split = path.split("/");
        final HashMap<Integer, String> map = new HashMap<>();
        final HashMap<String, Object> argsValues = new HashMap<>();
        for (int i = 1; i < split.length; i++) {
            final String s = split[i];
            if (s.contains("{") && s.contains("}")){
                map.put(i,s.substring(1,s.length()-1));
            }
        }
        split = requestPath.split("/");
        for (Integer index : map.keySet()) {
            argsValues.put(map.get(index),split[index]);
        }
        return argsValues;
    }
}
```

**PathVariableMethodArgumentResolver**

获取路径上的参数

思路:

1.以 / 分割源path，根据参数的变量找到对应的下标，记录

2.以 / 分割请求path，找到对应下标的值，返回

```java
public class PathVariableMethodArgumentResolver implements HandlerMethodArgumentResolver{


    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        final Annotation parameterAnnotation = parameter.getParameterAnnotation(PathVariable.class);
        if (ObjectUtils.isEmpty(parameterAnnotation)){
            return false;
        }
        return parameter.hasParameterAnnotation(PathVariable.class) && !(parameter.getParameterType() == Map.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest) throws Exception{
        final HttpServletRequest request = webServletRequest.getRequest();
        final String path = handlerMethod.getPath();
        final String requestPath = request.getRequestURI();
        int index = -1;
        PathVariable pathVariable = parameter.getParameterAnnotation(PathVariable.class);
        String key = pathVariable.value().equals("") ? parameter.getParameterName() : pathVariable.value();
        String[] split = path.split("/");
        for (int i = 1; i < split.length; i++) {
            final String s = split[i];
            if (s.contains("{") && s.contains("}") && s.contains(key)) {
                index = i;
                break;
            }
        }
        split = requestPath.split("/");
        Object result = index!=-1 ? split[index] : null;
        if (pathVariable.required() && ObjectUtils.isEmpty(result)) {
            throw new MissingPathVariableException(request.getRequestURI() + "缺少路径参数");
        }

        return result;
    }

```

**RequestCookieMethodArgumentResolver**

获取cookie中的值

遍历获取cookie当中的值即可

```java
public class RequestCookieMethodArgumentResolver implements HandlerMethodArgumentResolver{

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(CookieValue.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) throws Exception {

        final CookieValue cookieValue = parameter.getParameterAnnotation(CookieValue.class);
        String name = cookieValue.value().equals("") ? parameter.getParameterName() : cookieValue.value();

        final HttpServletRequest request = webServletRequest.getRequest();

        for (Cookie cookie : request.getCookies()) {
            if (cookie.getName().equals(name)){
                return convertComposite.convert(parameter.getParameterType(),cookie.getValue());
            }
        }
        return null;
    }
}
```

**RequestHeaderMapMethodArgumentResolver**

获取请求头中的所有参数

```java
public class RequestHeaderMapMethodArgumentResolver implements HandlerMethodArgumentResolver{
    @Override
    public boolean supportsParameter(MethodParameter parameter) {

        return parameter.hasParameterAnnotation(RequestHeader.class) && parameter.getParameterType() == Map.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) {

        final HttpServletRequest request = webServletRequest.getRequest();
        final Enumeration<String> headerNames = request.getHeaderNames();
        final HashMap<String, Object> args = new HashMap<>();
        while (headerNames.hasMoreElements()) {
            final String name = headerNames.nextElement();
            args.put(name,request.getHeader(name));
        }
        return args;
    }

}

```

**RequestHeaderMethodArgumentResolver**

获取请求头中的参数

```java
public class RequestHeaderMethodArgumentResolver implements HandlerMethodArgumentResolver{

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(RequestHeader.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) {
        final RequestHeader requestHeader = parameter.getParameterAnnotation(RequestHeader.class);
        final HttpServletRequest request = webServletRequest.getRequest();
        String key = requestHeader.value().equals("") ? parameter.getParameterName() : requestHeader.value();
        final String result = request.getHeader(key);
        if (ObjectUtils.isEmpty(result) && requestHeader.required()){
            throw new NullPointerException(parameter.getParameterType() + "not null");
        }
        return result;
    }
}
```

**RequestParamMapMethodArgumentResolver**

获取所有参数

```java
public class RequestParamMapMethodArgumentResolver implements HandlerMethodArgumentResolver{

    @Override
    public boolean supportsParameter(MethodParameter parameter) {

        if (parameter.hasParameterAnnotation(RequestParam.class) && parameter.getParameterType() == Map.class){
            return true;
        }else if (parameter.getParameterType() == Map.class){
            return true;
        }
        return false;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) throws Exception{
        final HttpServletRequest request = webServletRequest.getRequest();
        final HashMap<String, Object> args = new HashMap<>();
        final Map<String, String[]> parameterMap = request.getParameterMap();
        parameterMap.forEach((k,v)->{
            args.put(k,v[0]);
        });
        return args;
    }
}

```

**RequestParamMethodArgumentResolver**

获取参数

注意点：不标注任何注解可以获取参数

需要排除HttpServletRequest,HttpServletResponse,文件上传

```java
public class RequestParamMethodArgumentResolver implements HandlerMethodArgumentResolver{


    /**
     * 只接受 普通对象,基础数据类型
     * @param parameter
     * @return
     */
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.hasParameterAnnotation(RequestParam.class)){
            return true;
        }else {
            // 枚举其他解析器可以处理的参数
            final Class<?> parameterType = parameter.getParameterType();
            if (isMultipartFile(parameter)||
                    parameterType == HttpServletRequest.class ||
                    parameterType == HttpServletResponse.class||
                    parameter.hasParameterAnnotation(CookieValue.class)){
                return false;
            }else if (parameter.hasParameterAnnotation(RequestBody.class)){
                return false;
            }
            return true;
        }
    }

    /**
     * 处理组装数据为对象
     * @param parameter
     * @param handlerMethod
     * @param webServletRequest
     * @return
     * @throws Exception
     */
    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod,WebServletRequest webServletRequest, ConvertComposite convertComposite) throws Exception{
        final HttpServletRequest request = webServletRequest.getRequest();
        // 获取参数类型
        final Class<?> type = parameter.getParameterType();
        Object result = null;
        if (parameter.hasParameterAnnotation(RequestParam.class)){
            // 表单对象
            if(!BeanUtils.isSimpleProperty(type)){
                throw new HttpRequestBadRequestException("无法将 @RequestParam 标注在对象上, @RequestParam 作用是匹配参数名");
            }

            final RequestParam parameterAnnotation = parameter.getParameterAnnotation(RequestParam.class);
            String key = parameterAnnotation.value().equals("") ? parameter.getParameterName() : parameterAnnotation.value();
            result = convertComposite.convert(type,request.getParameter(key));
            if (parameterAnnotation.required() && ObjectUtils.isEmpty(parameter)) {
                throw new MissingServletRequestParameterException(request.getRequestURI()+"缺少请求参数");
            }
        }else {
            if (!BeanUtils.isSimpleProperty(type)) {
                final Map<String, String[]> parameterMap = request.getParameterMap();
                final Object o = type.newInstance();
                for (Field field : type.getDeclaredFields()) {
                    final String name = field.getName();
                    if (parameterMap.containsKey(name)){
                        field.setAccessible(true);
                        field.set(o,convertComposite.convert(field.getType(),parameterMap.get(name)[0]));
                        field.setAccessible(false);
                    }
                }
                result = o;
            }else {
                final String[] values = request.getParameterMap().get(parameter.getParameterName());
                result = values !=null ? convertComposite.convert(type,values[0]) : null;
            }
        }
        return result;
    }


	// 如果是文件上传，或者List中泛型写的是文件
    private boolean isMultipartFile(MethodParameter parameter){
        final Class<?> type = parameter.getParameterType();
        if (MultipartFile.class == type || type.getComponentType() == MultipartFile.class) {
            return true;
        }else if (Collection.class == type || List.class == type){
            final Type parameterGenericParameterType = parameter.getGenericParameterType();
            ParameterizedType pt = (ParameterizedType) parameterGenericParameterType;
            return pt.getActualTypeArguments()[0] == MultipartFile.class;
        }
        return false;
    }
}

```

**RequestRequestBodyMethodArgumentResolver**

解析json对象

```java
public class RequestRequestBodyMethodArgumentResolver implements HandlerMethodArgumentResolver {

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(RequestBody.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) throws Exception{
        final HttpServletRequest request = webServletRequest.getRequest();
        final RequestBody requestBody = parameter.getParameterAnnotation(RequestBody.class);

        final String jsonBody = getBody(request);
        if (ObjectUtils.isEmpty(jsonBody) && requestBody.required()){
            throw new MissingServletRequestParameterException(request.getRequestURI() + "需要请求体");
        }
        final ObjectMapper objectMapper = new ObjectMapper();

        try {
            return objectMapper.readValue(jsonBody, parameter.getParameterType());
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        return null;
    }
	// 获取请求体
    private static String getBody(HttpServletRequest request) {
        StringBuffer data = new StringBuffer();
        String line = null;

        try (BufferedReader reader = request.getReader()) {
            while (null != (line = reader.readLine()))
                data.append(line);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return data.toString();
    }
}
```

**ServletRequestMethodArgumentResolver**

```java
public class ServletRequestMethodArgumentResolver implements HandlerMethodArgumentResolver{
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType() == HttpServletRequest.class;

    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) {
        return webServletRequest.getRequest();
    }
}
```

**ServletResponseMethodArgumentResolver**

```java
public class ServletResponseMethodArgumentResolver implements HandlerMethodArgumentResolver{
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType() == HttpServletResponse.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, HandlerMethod handlerMethod, WebServletRequest webServletRequest, ConvertComposite convertComposite) {
        return webServletRequest.getResponse();
    }

}
```

### 参数解析器整合适配器

1.在DispatcherServlet中获取对应的适配器

2.适配器调用handler方法执行

3.在执行具体的HandlerMethod，可封装成可执行的HandlerMethod -> ServletInvocableMethod

**ServletInvocableMethod**

中存放执行业务所需要的组件  并且执行



```java
private Object invokeForRequest(WebServletRequest webServletRequest,HandlerMethod handler,Object... providedArgs) throws Exception {


        final Object[] parameters = getMethodArgumentValues(webServletRequest, handler, providedArgs);
        if (ObjectUtils.isEmpty(parameters)){
            return new Object[0];
        }
        return doInvoke(parameters);
    }
```



```java
protected Object[] getMethodArgumentValues(WebServletRequest webServletRequest,HandlerMethod handler,Object... providedArgs)throws Exception {
        final MethodParameter[] parameters = handler.getParameters();
        int n = parameters.length;
        Object[] args = new Object[n];

        for (int i = 0; i < n; i++) {
            final MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            // 尝试直接赋值参数
            args[i] = findProvidedArgument(parameter,providedArgs);
            if(args[i]!=null){
                continue;
            }
            // 参数解析器工作
            if (!this.argumentResolvers.supportsParameter(parameter)) {
                throw new IllegalStateException("not found parameter");
            }
            args[i] = this.argumentResolvers.resolveArgument(parameter,handler,webServletRequest,this.convertComposite);
        }
        return args;
    }
```





## 类型转换器

参数解析后获取的参数可能是Map，String，但是方法中需要的参数是各种各样的，因此需要枚举出所有可能性进行转换

枚举参数解析器当中出现类型的场景，枚举类型转换器

目标:

1.实现类型转换器

2.初始化类型转换器

3.类型转换器整合适配器

这一块代码太无聊了，都是创建同样的逻辑,就复制粘贴了

**实现：**

### Convert

```
public abstract class Convert<T> {

    protected Class<T> type;

    public Class<T> getType() {
        return type;
    }

    public Convert(Class<T> type){
        this.type = type;
     
    }
	
    protected abstract Object convert(Object arg) throws Exception;

    // 默认的类型转换逻辑
    protected Object convertType(String text) throws Exception {
        return type.getConstructor(String.class).newInstance(text);
    }

}
```

**ConvertHandler**

用于反射调用对应的Convert

为什么需要ConvertHandler是因为后续可能用户自定义类型转换器，不会遵循我们的Convert标注来

例如：

```java
@ConvertType(Integer.class)
public Object convert(Object arg){
  	// ...
}
```



```java
public class ConvertHandler extends HandlerMethod {



    public ConvertHandler(Object bean, Method method) {
        super(bean,method);
    }

    public Object convert(Object text) throws Exception {
        return this.getMethod().invoke(this.getBean(),text);
    }

}
```





初始化类型转换器

```java
final Map<Class, ConvertHandler> convertMap = new HashMap<>();
        convertMap.put(Integer.class,getConvertHandler(new IntegerConvert(Integer.class)));
        convertMap.put(int.class,getConvertHandler(new IntegerConvert(Integer.class)));
        convertMap.put(String.class,getConvertHandler(new StringConvert(String.class)));
        convertMap.put(Long.class,getConvertHandler(new LongConvert(Long.class)));
        convertMap.put(long.class,getConvertHandler(new LongConvert(Long.class)));
        convertMap.put(Float.class,getConvertHandler(new FloatConvert(Float.class)));
        convertMap.put(float.class,getConvertHandler(new FloatConvert(Float.class)));
        convertMap.put(Boolean.class,getConvertHandler(new BooleanConvert(Boolean.class)));
        convertMap.put(boolean.class,getConvertHandler(new BooleanConvert(Boolean.class)));
        convertMap.put(Byte.class,getConvertHandler(new ByteConvert(Byte.class)));
        convertMap.put(byte.class,getConvertHandler(new ByteConvert(Byte.class)));
        convertMap.put(Short.class,getConvertHandler(new ShortConvert(Short.class)));
        convertMap.put(short.class,getConvertHandler(new ShortConvert(Short.class)));
        convertMap.put(Date.class,getConvertHandler(new DateConvert(Date.class)));
        convertMap.put(Map.class,getConvertHandler(new MapConvert(HashMap.class)));
        convertMap.put(Collection.class,getConvertHandler(new CollectionConvert(Collection.class)));
        convertMap.put(List.class,getConvertHandler(new ListConvert(ArrayList.class)));
        convertMap.put(Set.class,getConvertHandler(new SetConvert(HashSet.class)));

 protected ConvertHandler getConvertHandler(Convert convert){
        try {
            final Method method = convert.getClass().getDeclaredMethod("convert", Object.class);
            return new ConvertHandler(convert,method);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        return null;
    }
```





## 返回值处理器

我们的web框架只有返回json这一个场景



**HandlerMethodReturnValueHandler**

```java
public interface HandlerMethodReturnValueHandler {

    boolean supportsReturnType(Method method);

    void handleReturnValue(Object returnValue, WebServletRequest webServletRequest) throws Exception;
}
```

 **RequestResponseBodyMethodReturnValueHandler**

具体实现的json 返回值处理器

```java
public class RequestResponseBodyMethodReturnValueHandler implements HandlerMethodReturnValueHandler{

    // 避免对应实体类没有get方法
    final ObjectMapper objectMapper = new ObjectMapper().setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);

   
    @Override
    public boolean supportsReturnType(Method method) {

        return AnnotatedElementUtils.hasAnnotation(method.getDeclaringClass(), ResponseBody.class) || method.isAnnotationPresent(ResponseBody.class);
    }

    @Override
    public void handleReturnValue(Object returnValue, WebServletRequest webServletRequest) throws Exception {
        final HttpServletResponse response = webServletRequest.getResponse();
        responseBody(returnValue,response);
    }
    private void responseBody(Object value, HttpServletResponse response) throws IOException {
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.getWriter().println(objectMapper.writeValueAsString(value));
        response.getWriter().flush();
    }
}
```



**HandlerMethodReturnValueHandlerComposite**

返回值组合器

```java
public class HandlerMethodReturnValueHandlerComposite  {

    private List<HandlerMethodReturnValueHandler> returnValueArgumentResolverList = new ArrayList<>();

    public List<HandlerMethodReturnValueHandler> getReturnValueArgumentResolvers() {
        return returnValueArgumentResolverList;
    }

    public void addArgumentResolver(List<HandlerMethodReturnValueHandler> resolvers){
        this.returnValueArgumentResolverList.addAll(resolvers);
    }

    public void handleReturnValue(Object returnValue, WebServletRequest webServletRequest, Method method) {

        // 选择返回值处理器
        final HandlerMethodReturnValueHandler returnValueHandler = selectHandler(method);
        // 执行
        try {
            returnValueHandler.handleReturnValue(returnValue,webServletRequest);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private HandlerMethodReturnValueHandler selectHandler(Method method) {
        for (HandlerMethodReturnValueHandler handlerMethodReturnValueHandler : this.returnValueArgumentResolverList) {
            if (handlerMethodReturnValueHandler.supportsReturnType(method)) {
                return handlerMethodReturnValueHandler;
            }
        }
        return null;
    }
    
}

```





## 异常解析器

在适配器执行过程中可能会出现异常，并且我们需要对异常进行捕获，额外的处理，因此需要有一个异常解析器

在出现异常的时候进行捕获，并且后续执行时如果有异常则执行

**HandlerExceptionResolver**



```java
public interface HandlerExceptionResolver extends Ordered {

     Boolean resolveException(HttpServletRequest request, HttpServletResponse response, HandlerMethod handler, Exception ex) throws Exception;

     void setOrder(int orderId);
}
```



**ExceptionHandlerExceptionResolver**

这里的实现留在后续拓展点实现

处理用户定义的异常解析器，需要反射执行对应方法，并且填充参数

可填参数:

1.Excpetion

2.HttpServletRequest,response

3.HandlerMethod



**DefaultHandlerExceptionResolver**

默认的异常解析器

用于处理默认的异常



枚举出异常:

NotFoundExcpetion

1.找不到参数解析器

2.找不到类型转换器

3.找不到返回值处理器

4.找不到适配器

4.5 ... 等等等找不到

HttpRequestMethodNotSupport

5.请求类型不匹配



6.映射器已存在

ConvertCastExcpetion

7.类型转换失败



## 拓展点

定义@ControllerAdvice为全局拓展点，其中可以存放全局异常解析器，类型转换器

### 异常解析器拓展点

**设计**

**全局异常解析器初始化**

在ExceptionHandlerExceptionResolver 中找到ControllerAdvice下标注了@ExcpetionHandler的方法,

包装为ExceptionHandlerMethod存放在map中，key为ex，value为ExceptionHandlerMethod

**局部异常解析器初始化**

在初始化HandlerMethod时，顺便找当前controller中的方法是否存在标注了@ExceptionHandler的方法进行保存放在HandlerMethod当中

```java
@ExcpetionHandler(Exception.class)
public String ex(Excpetion ex,HandlerMethod ,Request){
  
}
```



**执行**

在执行ExceptionHandlerExceptionResolver时，先判断局部异常解析器是否存在，如果没有则全局异常。

并且在找的时候需要向上递归去找

### 类型转换器拓展点

**设计**

**全局类型转换器初始化**

在适配器当中，初始化默认类型转换器后，找@ControllerAdvice中的类下所有标注了@ConvertType包装为ConvertHandler添加到全局类型转换器中

**局部类型转换器初始化**

在初始化HandlerMethod时，顺便找当前controller中的方法是否存在标注了@ConvertType的方法进行保存放在HandlerMethod当中

**执行**

在参数解析器转换类型时，带上HandlerMethod。先局部，后全局

### EnableWebMvc

EnableWebMvc功能:

1.以容器化方式初始化组件 -> 因此可以自定义组件被容器初始化

2.添加拓展点 -> 拦截器 -> 类型转换器



```java
class XXWebMvcConfig im WebMvcConfg{
  // 添加拦截器
}
```





设计:

假设只需要以容器方式初始化：

那么只需要导入一个类，在该类中注入组件即可

但是还需要考虑到拓展点

可以使用委派模式



**@EnableWebMvc**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}
```

 **WebMvcConfigurationSupport**

初始化组件，并且留拓展点给子类

拓展点：拦截器,类型转换器

**DelegatingWebMvcConfiguration**

委派模式，用于将配置信息委派给其他组件

**WebMvcConfigurer**

定义拓展点规范

**WebMvcComposite**

组合器中保存所有的WebMvcConfigurer下的bean

DelegatingWebMvcConfiguration委派交给了组合器，组合器遍历WebMvcConfigurer执行拓展点逻辑



![image.png](https://cdn.nlark.com/yuque/0/2023/png/29091062/1697379683248-0fe8545c-b998-41f1-9ab4-ef66776233d5.png)



**流程**

>   0.标注EbableWebMvc注解 带有DelegatingWebMvcConfiguration
>
>   1.导入DelegatingWebMvcConfiguration
>
>   2.会将WebMvcConfigurationSupport导入
>
>   3.在WebMvcConfigurationSupport中初始化组件，并且留给DelegatingWebMvcConfiguration拓展点
>
>   4.在DelegatingWebMvcConfiguration中调用组合器中方法
>
>   5.组合器中存放所有的WebMvcConfigurer的子类，最后会调用到我们自定义的DiyWebMvcConfigurer





### 拦截器实现

拓展点中存放拦截器注册中心供用户注册拦截器，注册时包装为InterceptorRegistration,获取所有拦截器时转换为MappedInterceptor

HandlerInterceptor 拦截器接口

InterceptorRegistration 封装拦截器信息

InterceptorRegistry 拦截器注册中心,留给用户添加拦截器

MappedInterceptor 拥有路径映射的功能的拦截器





**HandlerInterceptor**

定义拦截器接口标准

```java
default boolean preHandle(HttpServletRequest request, HttpServletResponse response){
        return true;
    }

    default void  postHandle(HttpServletRequest request, HttpServletResponse response){}

    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
                                  Exception ex){
    }
```

**InterceptorRegistration**

封装拦截器信息

```java
public class InterceptorRegistration {
  
    // 拦截器
    private  HandlerInterceptor interceptor;
    // 拦截路径
    private List<String> includePatterns = new ArrayList<>();
    // 排除路径
    private List<String> excludePatterns = new ArrayList<>();
}
```

**InterceptorRegistry**

拦截器注册中心

```java
public class InterceptorRegistry {

    private List<InterceptorRegistration> registrations = new ArrayList<>();
  // 转换 InterceptorRegistration - > MappedInterceptor
    public List<HandlerInterceptor> getRegistrations() {

        return registrations.stream().map(InterceptorRegistration::getMappedInterceptor).collect(Collectors.toList());
    }
}
```

**MappedInterceptor**

用于处理路径映射匹配

```java
public class MappedInterceptor implements HandlerInterceptor{

    private HandlerInterceptor interceptor;

    private List<String> includePatterns = new ArrayList<>();

    private List<String> excludePatterns = new ArrayList<>();

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();

    public MappedInterceptor(HandlerInterceptor interceptor, List<String> includePatterns, List<String> excludePatterns) {
        this.interceptor = interceptor;
        this.includePatterns = includePatterns;
        this.excludePatterns = excludePatterns;
    }

    // 路径匹配
    public boolean match(String path){
        for (String excludePattern : this.excludePatterns) {
            if (antPathMatcher.match(excludePattern,path)){
                return false;
            }
        }
        for (String includePattern : this.includePatterns) {
            if (antPathMatcher.match(includePattern,path)){
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response) {
        return interceptor.preHandle(request,response);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response) {
        interceptor.postHandle(request,response);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        interceptor.afterCompletion(request,response,handler,ex);
    }
}

```

###  



## 整合SpringBoot

设计:

1.内嵌式tomcat启动

2.添加配置文件

3.修改BaseHttpServlet中 web ioc刷新逻辑

>   在springboot当中，选择ioc是通过WebApplicationType来决定的

```java
WebApplicationType{
  NONE,
  SERVLET,
  REACTIVE
}
```

判断使用哪个WebApplicationType

```java
	private static final String[] SERVLET_INDICATOR_CLASSES = { "javax.servlet.Servlet",
			"org.springframework.web.context.ConfigurableWebApplicationContext" };

	private static final String WEBMVC_INDICATOR_CLASS = "org.springframework.web.servlet.DispatcherServlet";

	private static final String WEBFLUX_INDICATOR_CLASS = "org.springframework.web.reactive.DispatcherHandler";

	private static final String JERSEY_INDICATOR_CLASS = "org.glassfish.jersey.servlet.ServletContainer";

static WebApplicationType deduceFromClasspath() {
  		// 响应式启动
		if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
				&& !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
			return WebApplicationType.REACTIVE;
		}
  		// 默认的ioc启动
		for (String className : SERVLET_INDICATOR_CLASSES) {
			if (!ClassUtils.isPresent(className, null)) {
				return WebApplicationType.NONE;
			}
		}
  // web ioc启动
		return WebApplicationType.SERVLET;
	}
```



我们的web ioc 刷新代码

AbstractRefreshableWebApplicationContext wac = (AbstractRefreshableWebApplicationContext) this.webApplicationContext;这一行代码就会报错

因为从源码得出，给的ioc容器，是springboot提供的，转换不了，并且在springboot中也没有父子容器概念，都是同一个容器，因此这里需要多加一层判断即可。如果是springboot的ioc，我们只需要调用onRefresh(webApplicationContext);

>   springboot默认提供的ioc ： AnnotationConfigApplicationContext



```java
 public void init() throws ServletException {
        final ServletContext servletContext = getServletContext();

        ApplicationContext rootContext = (ApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_NAME);

        if (!ObjectUtils.isEmpty(webApplicationContext)){
            // 需要转换
            AbstractRefreshableWebApplicationContext wac = (AbstractRefreshableWebApplicationContext) this.webApplicationContext;

            // 设置父子容器
            if (wac.getParent() == null){
                wac.setParent(rootContext);
            }
            // 配置上下文
            wac.setServletContext(servletContext);
            wac.setServletConfig(getServletConfig());
            // web容器刷新
            wac.refresh();
        }
        onRef
```





### 内嵌式tomcat启动

依赖

```
<!-- https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-core -->
```

```java
<dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-jasper</artifactId>
            <version>9.0.68</version>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-core</artifactId>
            <version>9.0.68</version>
        </dependency>
```



**当时遇到的坑**

>   在xhy-web当时tomat 版本8.0X
>
>   和springboot整合的时候，xhy-web 里面的依赖都要遵循springboot的依赖-> 使用的9.0X

差异

8.0不用加tomcat.getConnector();

9.0X必须加



第二个问题，以为tomat没启动

在main当中启动内嵌式tomcat

输出了端口



和springboot整合的时候没有输出端口 -> 我就以为没有启动成功





测试内嵌式tomcat启动

```java
Integer port = serverProperties.getPort();
        tomcat.setPort(8080);
        tomcat.setHostname("localhost");
        tomcat.setBaseDir(".");
        final Context context = tomcat.addWebapp("/", System.getProperty("user.dir") + "/src/main");
        final Wrapper wrapper =
                tomcat.addServlet(context, "xhy-web", new DispatcherServlet(this.applicationContext));
       
        wrapper.setMultipartConfigElement(new MultipartConfigElement(null, 5 * M, 5 * M,5));
        wrapper.addMapping("/");
        tomcat.getConnector();
        tomcat.start();
        logger.info("Tomcat initialized with port: "+port);
        tomcat.getServer().await();
        return tomcat;
```

**XhyWebAutoConfigure**

```java
@Configuration
@EnableWebMvc
public class XhyWebAutoConfigure implements ApplicationContextAware {

    ApplicationContext applicationContext;

    private static final int M = 1024* 1024;

    private static final Log logger = LogFactory.getLog(XhyWebAutoConfigure.class);

    @Bean
    public MultipartFileProperties multipartFileProperties(){
        return new MultipartFileProperties();
    }

    @Bean
    public ServerProperties serverProperties(){
        return new ServerProperties();
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    @Bean
    public Tomcat tomcat(ServerProperties serverProperties,MultipartFileProperties multipartFileProperties) throws LifecycleException {
        Integer port = serverProperties.getPort();
        Tomcat tomcat = new Tomcat();
        port = port == null ? 8080 : port;
        tomcat.setPort(port);
        tomcat.setHostname("localhost");
        tomcat.setBaseDir(".");
        final Context context = tomcat.addWebapp("/", System.getProperty("user.dir") + "/src/main");
        final Wrapper wrapper =
                tomcat.addServlet(context, "xhy-web", new DispatcherServlet(this.applicationContext));
        Long requestFileSize = multipartFileProperties.getFileSize();
        requestFileSize = requestFileSize == null ? 5L :requestFileSize;
        wrapper.setMultipartConfigElement(new MultipartConfigElement(null, requestFileSize * M, requestFileSize * M,5));
        wrapper.addMapping("/");
        tomcat.getConnector();
        tomcat.start();
        logger.info("Tomcat initialized with port: "+port);
        tomcat.getServer().await();
        return tomcat;
    }

}
```

**MultipartFileProperties**

```java
@ConfigurationProperties(prefix = "web")
@EnableConfigurationProperties(MultipartFileProperties.class)
public class MultipartFileProperties {

    private Long fileSize;

    public Long getFileSize() {
        return fileSize;
    }

    public void setFileSize(Long fileSize) {
        this.fileSize = fileSize;
    }
}
```

SPI配置



## 功能测试

排查代码遗留问题以及项目可行性

### 路径

1.请求类型不匹配 -> 什么都没输出 

### 传参

1.文件上传时，参数名不同也能拿到文件

### 拦截器映射

### 异常解析器

### 类型转换器







**完结撒花！**

